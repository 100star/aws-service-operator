// >>>>>>> DO NOT EDIT THIS FILE <<<<<<<<<<
// This file is autogenerated via `aws-operator generate`
// If you'd like the change anything about this file make edits to the .templ
// file in the pkg/codegen/assets directory.

package dynamodb

import (
	 metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	 apiv1 "k8s.io/api/core/v1"
	"github.com/christopherhein/aws-operator/pkg/helpers"
	"reflect"

	"github.com/christopherhein/aws-operator/pkg/config"
  "github.com/christopherhein/aws-operator/pkg/queue"
	opkit "github.com/christopherhein/operator-kit"
	apiextensionsv1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
	"k8s.io/client-go/tools/cache"

	awsapi "github.com/christopherhein/aws-operator/pkg/apis/operator.aws"
	awsV1alpha1 "github.com/christopherhein/aws-operator/pkg/apis/operator.aws/v1alpha1"
	awsclient "github.com/christopherhein/aws-operator/pkg/client/clientset/versioned/typed/operator.aws/v1alpha1"
)

// Resource is the object store definition
var Resource = opkit.CustomResource{
	Name:       "dynamodb",
	Plural:     "dynamodbs",
	Group:      awsapi.GroupName,
	Version:    awsapi.Version,
	Scope:      apiextensionsv1beta1.NamespaceScoped,
	Kind:       reflect.TypeOf(awsV1alpha1.DynamoDB{}).Name(),
	ShortNames: []string{
		"ddb",
		"ddbs",
		"dynamo",
		"dynamotable",
		"dynamotables",
	},
}

// Controller represents a controller object for object store custom resources
type Controller struct {
	config       *config.Config
	context      *opkit.Context
	awsclientset awsclient.OperatorV1alpha1Interface
  topicARN     string
}

type data struct {
	Obj    *awsV1alpha1.DynamoDB
	Config *config.Config
}

// NewController create controller for watching object store custom resources created
func NewController(config *config.Config, context *opkit.Context, awsclientset awsclient.OperatorV1alpha1Interface) *Controller {
	return &Controller{
		config:       config,
		context:      context,
		awsclientset: awsclientset,
	}
}

// StartWatch watches for instances of Object Store custom resources and acts on them
func (c *Controller) StartWatch(namespace string, stopCh chan struct{}) error {
	resourceHandlers := cache.ResourceEventHandlerFuncs{
		AddFunc:    c.onAdd,
		UpdateFunc: c.onUpdate,
		DeleteFunc: c.onDelete,
	}
	queuectrl := queue.New(c.config, c.context, c.awsclientset, 1)
	c.topicARN, _, _, _ = queuectrl.Register("dynamodb", &awsV1alpha1.DynamoDB{})
	go queuectrl.StartWatch(queue.HandlerFunc(QueueUpdater), stopCh)

	restClient := c.awsclientset.RESTClient()
	watcher := opkit.NewWatcher(Resource, namespace, resourceHandlers, restClient)
	go watcher.Watch(&awsV1alpha1.DynamoDB{}, stopCh)

	return nil
}
// QueueUpdater will take the messages from the queue and process them
func QueueUpdater(config *config.Config, msg *queue.MessageBody) error {
	if msg.Updatable {
		err := updateStatus(config, msg.ResourceName, msg.Namespace, msg.ParsedMessage["StackId"], msg.ParsedMessage["ResourceStatus"], msg.ParsedMessage["ResourceStatusReason"])
		if err != nil {
			return err
		}
	}
	return nil
}

func (c *Controller) onAdd(obj interface{}) {
	s := obj.(*awsV1alpha1.DynamoDB).DeepCopy()
  if s.Status.ResourceStatus == "" {
    cft := New(c.config, s, c.topicARN)
    output, err := cft.CreateStack()
    if err != nil {
      c.config.Logger.WithError(err).Errorf("error creating dynamodb '%s'", s.Name)
      return
    }
    c.config.Logger.Infof("added dynamodb '%s' with stackID '%s'", s.Name, string(*output.StackId))
    c.config.Logger.Infof("view at https://console.aws.amazon.com/cloudformation/home?#/stack/detail?stackId=%s", string(*output.StackId))

		err = updateStatus(c.config, s.Name, s.Namespace, string(*output.StackId), "CREATE_IN_PROGRESS", "")
		if err != nil {
			c.config.Logger.WithError(err).Error("error updating status")
		}

		err = c.syncAdditionalResources(s)
		if err != nil {
			c.config.Logger.WithError(err).Error("error syncing resources")
		}
  }
}

func (c *Controller) onUpdate(oldObj, newObj interface{}) {
	oo := oldObj.(*awsV1alpha1.DynamoDB).DeepCopy()
	no := newObj.(*awsV1alpha1.DynamoDB).DeepCopy()
  if helpers.IsStackComplete(oo.Status.ResourceStatus, false) {
    cft := New(c.config, oo, c.topicARN)
    output, err := cft.UpdateStack(no)
    if err != nil {
      c.config.Logger.WithError(err).Errorf("error updating dynamodb '%s' with new params %+v and old %+v", no.Name, no, oo)
      return
    }
    c.config.Logger.Infof("updated dynamodb '%s' with params '%s'", no.Name, string(*output.StackId))
    c.config.Logger.Infof("view at https://console.aws.amazon.com/cloudformation/home?#/stack/detail?stackId=%s", string(*output.StackId))

		err = updateStatus(c.config, oo.Name, oo.Namespace, string(*output.StackId), "UPDATE_IN_PROGRESS", "")
		if err != nil {
			c.config.Logger.WithError(err).Error("error updating status")
		}

		err = c.syncAdditionalResources(no)
		if err != nil {
			c.config.Logger.WithError(err).Info("error syncing resources")
		}
  }
}

func (c *Controller) onDelete(obj interface{}) {
	s := obj.(*awsV1alpha1.DynamoDB).DeepCopy()
  if helpers.IsStackComplete(s.Status.ResourceStatus, false) {
    cft := New(c.config, s, c.topicARN)
    err := cft.DeleteStack()
    if err != nil {
      c.config.Logger.WithError(err).Errorf("error deleting dynamodb '%s'", s.Name)
      return
    }

    c.config.Logger.Infof("deleted dynamodb '%s'", s.Name)
  }
}
func updateStatus(config *config.Config, name string, namespace string, stackID string, status string, reason string) error {
		logger := config.Logger
		clientSet, _ := awsclient.NewForConfig(config.RESTConfig)
		resource, err := clientSet.DynamoDBs(namespace).Get(name, metav1.GetOptions{})
		if err != nil {
			logger.WithError(err).Error("error getting dynamodbs")
			return err
		}

		resourceCopy := resource.DeepCopy()
		resourceCopy.Status.ResourceStatus = status
		resourceCopy.Status.ResourceStatusReason = reason
		resourceCopy.Status.StackID = stackID

		if helpers.IsStackComplete(status, true) {
			cft := New(config, resourceCopy, "")
			outputs, err := cft.GetOutputs()
			if err != nil {
				logger.WithError(err).Error("error getting outputs")
			}
			resourceCopy.Output.TableName = outputs["TableName"]
			resourceCopy.Output.TableARN = outputs["TableArn"]
		}

		_, err = clientSet.DynamoDBs(namespace).Update(resourceCopy)
		if err != nil {
			logger.WithError(err).Error("error updating resource")
			return err
		}
		return nil
}

func (c *Controller) syncAdditionalResources(s *awsV1alpha1.DynamoDB) (err error) {
	clientSet, _ := awsclient.NewForConfig(c.config.RESTConfig)
	resource, err := clientSet.DynamoDBs(s.Namespace).Get(s.Name, metav1.GetOptions{})
	if err != nil {
		return err
	}
	resource = resource.DeepCopy()

	
	


	_, err = clientSet.DynamoDBs(s.Namespace).Update(resource)
	if err != nil {
		return err
	}
  return nil
}


func createService(config *config.Config, s *awsV1alpha1.DynamoDB, svcType string, externalName string) string {
	logger := config.Logger
	service := &apiv1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name: s.Name+"-service",
		},
		Spec: apiv1.ServiceSpec{
			Type: helpers.ServiceType(svcType),
			ExternalName: externalName,
			Ports: []apiv1.ServicePort{
				apiv1.ServicePort{
					Port: 443,
				},
			},
		},
	}

	newService, err := config.Context.Clientset.CoreV1().Services(s.Namespace).Create(service)
	if err != nil {
		logger.WithError(err).Error("error creating service")
	}
	return newService.Name
}
